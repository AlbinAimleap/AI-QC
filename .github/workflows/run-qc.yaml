name: QC-AI Test
run-name: QC-AI Test || ${{ github.event.inputs.branch }}

on:
  workflow_dispatch:
    inputs:
      branch:
        description: "Branch to Run"
        required: true
        default: "main"
      code_file:
        description: "What is your code file name? (without spaces, lowercase)"
        required: true
        default: "your_code"
      prompt_file:
        description: "What is your prompt file name? (without spaces, lowercase)"
        required: false
        default: ""
      checklist_file:
        description: "What is your checklist file name? (without spaces, lowercase)"
        required: false
        default: ""
  repository_dispatch:
    types:
      - trigger-qc-test

jobs:
  setup-aws-credentials:
    runs-on: ubuntu-24.04 

    steps:
    - name: Checkout Code
      uses: actions/checkout@v3
      with:
        ref: ${{ github.event.inputs.branch }}

    - name: Set AWS Credentials
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      run: |
        echo "AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}" >> $GITHUB_ENV
        echo "AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}" >> $GITHUB_ENV

    - name: Install AWS CLI
      run: |
        # Install AWS CLI using Snap
        sudo snap install aws-cli --classic
        aws --version 

    - name: Install Python Dependencies
      run: |
        # Install Python dependencies
        python3 -m pip install --upgrade pip
        pip install boto3 python-dotenv

    - name: Run QC Script
      run: |
        ls -l .
        CODE_FILES="${{ github.event.inputs.code_file }}"
        PROMPT_FILE="${{ github.event.inputs.prompt_file }}"
        CHECKLIST_FILE="${{ github.event.inputs.checklist_file }}"
        OUTPUT_FILE="qc_output.log"

        # Convert comma-separated code files to space-separated and append .py
        CONTEXT_FILES=$(echo "$CODE_FILES" | tr ',' ' ' | sed 's/\([^ ]*\)/\1.py/g')

        if [[ -z "$PROMPT_FILE" && -z "$CHECKLIST_FILE" ]]; then
          echo "Running basic QC with context files: $CONTEXT_FILES"
          python qc.py --context $CONTEXT_FILES > "$OUTPUT_FILE" 2>&1
        else
          PROMPT_FILE="${PROMPT_FILE}.txt"
          CHECKLIST_FILE="${CHECKLIST_FILE}.txt"
          echo "Running QC with context: $CONTEXT_FILES, prompt: $PROMPT_FILE, checklist: $CHECKLIST_FILE"
          python qc.py --context $CONTEXT_FILES --prompt "$PROMPT_FILE" --checklist "$CHECKLIST_FILE" > "$OUTPUT_FILE" 2>&1
        fi
    - name: Display QC Output
      run: |
        echo "==== QC Script Output ===="
        cat qc_output.log

    - name: Create GitHub Issue on Error
      if: ${{ always() }}
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        # Check for error status in QC output
        if grep -q '"status": "error"' qc_output.log; then
          echo "Error detected, parsing output and creating GitHub issue..."

          # Read and parse the JSON log
          ISSUE_TITLE="${{ github.workflow }} || ${{ github.event.inputs.branch }}"
          QC_OUTPUT=$(cat qc_output.log | tr -d '\r' | awk -v RS='--+' 'NR>1{print $0}' | grep -v '^[[:space:]]*$')

          # Parse the JSON for code and quality issues
          MARKDOWN_BODY=$(echo "$QC_OUTPUT" | jq -s '
            . | map(
              "# " + .file_name + "\n\n" +
              "## Analysis Report " + (.metadata.timestamp | sub("T"; " ") | sub("Z"; " UTC")) + "\n\n" +
              if (.checks.code_issues | length > 0) then
                "## Code Issues\n\n" +
                (.checks.code_issues | to_entries | map(
                  "### Issue " + (.key + 1 | tostring) + "\n\n" +
                  "**Line:** \( .value.line )  \n" +
                  "**Severity:** \( .value.severity )  \n" +
                  "**Message:** \( .value.message )  \n" +
                  "**Error Code:** \( .value.error_code )  \n" +
                  "**Fix:** \( .value.fix )  \n" +
                  "**Category:** \( .value.category )\n\n"
                ) | join(""))
              else
                "## Code Issues\n\nNo Code Issues Found.\n\n"
              end +
              if (.checks.quality_issues | length > 0) then
                "## Quality Issues\n\n" +
                (.checks.quality_issues | to_entries | map(
                  "### Issue " + (.key + 1 | tostring) + "\n\n" +
                  "**Issue:** \( .value.issue )  \n" +
                  "**Severity:** \( .value.severity )  \n" +
                  "**Impact:** \( .value.impact )  \n" +
                  "**Best Practice:** \( .value.best_practice )  \n" +
                  "**Fix:** \( .value.fix )\n\n"
                ) | join(""))
              else
                "## Quality Issues\n\nNo Quality Issues Found.\n\n"
              end +
              "## Metrics\n\n" +
              "- Complexity: \( .checks.metrics.complexity )\n" +
              "- Maintainability: \( .checks.metrics.maintainability )\n" +
              "- Test Coverage: \( .checks.metrics.test_coverage )\n" +
              "- Duplication: \( .checks.metrics.duplication )\n"
            ) | join("\n---\n\n")
          ')

          # Create GitHub issue using gh CLI
          gh issue create \
            --title "$ISSUE_TITLE" \
            --body "$MARKDOWN_BODY" \
            --repo "${{ github.repository }}"
        else
          echo "No error detected, skipping issue creation."
        fi